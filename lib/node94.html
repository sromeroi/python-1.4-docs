<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>10.4 What Is Deterministic Profiling?</TITLE>
<META NAME="description" CONTENT="10.4 What Is Deterministic Profiling?">
<META NAME="keywords" CONTENT="lib">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="lib.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html3424" HREF="node95.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="../icons/next_motif.gif" BORDER=0></A> <A NAME="tex2html3422" HREF="node90.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="../icons/up_motif.gif" BORDER=0></A> <A NAME="tex2html3416" HREF="node93.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="../icons/previous_motif.gif" BORDER=0></A> <A NAME="tex2html3426" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="../icons/contents_motif.gif" BORDER=0></A> <A NAME="tex2html3427" HREF="node221.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="../icons/index_motif.gif" BORDER=0></A> <BR>
<B> Next:</B> <A NAME="tex2html3425" HREF="node95.html">10.5 Reference Manual</A>
<B>Up:</B> <A NAME="tex2html3423" HREF="node90.html">10 The Python Profiler</A>
<B> Previous:</B> <A NAME="tex2html3417" HREF="node93.html">10.3 Instant Users Manual</A>
<BR><HR><P>
<H1><A NAME="SECTION001140000000000000000">10.4 What Is Deterministic Profiling?</A></H1>
<P>
<A NAME="DeterministicProfiling">&#160;</A>
<P>
<I><DFN>Deterministic profiling</DFN></I> is meant to reflect the fact that all
<I><DFN>function call</DFN></I>, <I><DFN>function return</DFN></I>, and <I><DFN>exception</DFN></I> events
are monitored, and precise timings are made for the intervals between
these events (during which time the user's code is executing).  In
contrast, <I><DFN>statistical profiling</DFN></I> (which is not done by this
module) randomly samples the effective instruction pointer, and
deduces where time is being spent.  The latter technique traditionally
involves less overhead (as the code does not need to be instrumented),
but provides only relative indications of where time is being spent.
<P>
In Python, since there is an interpreter active during execution, the
presence of instrumented code is not required to do deterministic
profiling.  Python automatically provides a <I><DFN>hook</DFN></I> (optional
callback) for each event.  In addition, the interpreted nature of
Python tends to add so much overhead to execution, that deterministic
profiling tends to only add small processing overhead in typical
applications.  The result is that deterministic profiling is not that
expensive, yet provides extensive run time statistics about the
execution of a Python program.
<P>
Call count statistics can be used to identify bugs in code (surprising
counts), and to identify possible inline-expansion points (high call
counts).  Internal time statistics can be used to identify ``hot
loops'' that should be carefully optimized.  Cumulative time
statistics should be used to identify high level errors in the
selection of algorithms.  Note that the unusual handling of cumulative
times in this profiler allows statistics for recursive implementations
of algorithms to be directly compared to iterative implementations.
<P>
<BR> <HR>
<P><ADDRESS>
guido@cnri.reston.va.us
</ADDRESS>
</BODY>
</HTML>
