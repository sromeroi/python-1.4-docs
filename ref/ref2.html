<P><A HREF="ref.book.html"><IMG SRC="fm2html-toc.gif">Table of Contents</A>
<A HREF="ref1.html"><IMG SRC="fm2html-previous.gif">Previous Chapter</A>
<!-- This file was created with the fm2html filter.
The filter is copyright Norwegian Telecom Research and
was programmed by Jon Stephenson von Tetzchner. -->

<PRE>
</PRE>

<H2><A NAME="HDR0"> Chapter 2:  Lexical analysis</A></H2>
<P>A Python program is read by a <I>parser</I>. Input to the parser is a stream of <I>tokens</I>, generated by the <I>lexical analyzer</I>. This chapter describes how the lexical analyzer breaks a file into tokens.
<P>Python uses the (7-bit) ASCII character set for program text and string literals. 8-bit characters may be used in string literals and comments but their interpretation is platform dependent; the proper way to insert 8-bit characters in string literals is by using octal or hexadecimal escape sequences.
<P>The run-time character set depends on the I/O devices connected to the program but is generally a superset of ASCII.
<H3><A NAME="HDR1"> 2.1  Line structure</A></H3>
<P>A Python program is divided in a number of <I>logical lines</I>.
<H4><A NAME="HDR2"> 2.1.1  Logical lines</A></H4>
<P>The end of each logical line is represented by the token NEWLINE. Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g. between statements in compound statements). A logical line is constructed from one or more <I>physical lines</I> by following the explicit or implicit <I>line joining</I> rules.<I>
<H4><A NAME="HDR3"> 2.1.2  Physical lines</A></H4>
<P></I>A physical line ends in whatever the current platform's convention is for terminating lines. On UNIX, this is the ASCII LF (linefeed) character. On DOS/Windows, it is the ASCII sequence CR LF (return followed by linefeed). On Macintosh, it is the ASCII CR (return) character.
<H4><A NAME="HDR4"> 2.1.3  Comments</A></H4>
<P>A comment starts with a hash character (<CODE>#</CODE>) that is not part of a string literal, and ends at the end of the physical line. A comment signifies the end of the logical line unless the implicit line joining rules are invoked. Comments are ignored by the syntax\xad \xad ; they are not tokens.
<H4><A NAME="HDR5"> 2.1.4  Explicit line joining</A></H4>
<P>Two or more physical lines may be joined into logical lines using backslash characters (<CODE>\</CODE>), as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it is joined with the following forming a single logical line, deleting the backslash and the following end-of-line character. For example:
<PRE>
if 1900 &lt; year &lt; 2100 and 1 &lt;= month &lt;= 12 \ 
   and 1 &lt;= day &lt;= 31 and 0 &lt;= hour &lt; 24 \ 
   and 0 &lt;= minute &lt; 60 and 0 &lt;= second &lt; 60:   # Looks like a valid date 
        return 1 
</PRE>
<P>A line ending in a backslash cannot carry a comment. A backslash does not continue a comment. A backslash does not continue a token except for string literals (i.e., tokens other than string literals cannot be split across physical lines using a backslash). A backslash is illegal elsewhere on a line outside a string literal.

<H4><A NAME="HDR6"> 2.1.5  Implicit line joining</A></H4>
<P>Expressions in parentheses, square brackets or curly braces can be split over more than one physical line without using backslashes. For example:
<PRE>
month_names = ['Januari', 'Februari', 'Maart',      # These are the 
               'April',   'Mei',      'Juni',       # Dutch names 
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year 
</PRE>
<P>Implicitly continued lines can carry comments. The indentation of the continuation lines is not important. Blank continuation lines are allowed. There is no NEWLINE token between implicit continuation lines. Implicit continued lines can also occur within triple-quoted strings (see below); in that case they cannot carry comments.
<H4><A NAME="HDR7"> 2.1.6  Blank lines</A></H4>
<P>A logical line that contains only spaces, tabs, formfeeds, and possibly a comment, is ignored (i.e., no NEWLINE token is generated), except that during interactive input of statements, an entirely blank logical line (i.e. one containing not even whitespace or a comment) terminates a multi-line statement.
<H4><A NAME="HDR8"> 2.1.7  Indentation</A></H4>
<P>Leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements.
<P>First, tabs are replaced (from left to right) by one to eight spaces such that the total number of characters up to there is a multiple of eight (this is intended to be the same rule as used by UNIX). The total number of spaces preceding the first non-blank character then determines the line's indentation. Indentation cannot be split over multiple physical lines using backslashes; the whitespace up to the first backslash determines the indentation.
<P>A formfeed character may be present at the start of the line; formfeed characters occurring elsewhere in the leading whitespace have an undefined effect (for instance, they may reset the space count to zero).
<P>The indentation levels of consecutive lines are used to generate INDENT and DEDENT tokens, using a stack, as follows. 
<P>Before the first line of the file is read, a single zero is pushed on the stack; this will never be popped off again. The numbers pushed on the stack will always be strictly increasing from bottom to top. At the beginning of each logical line, the line's indentation level is compared to the top of the stack. If it is equal, nothing happens. If it is larger, it is pushed on the stack, and one INDENT token is generated. If it is smaller, it <I>must</I> be one of the numbers occurring on the stack; all numbers on the stack that are larger are popped off, and for each number popped off a DEDENT token is generated. At the end of the file, a DEDENT token is generated for each number remaining on the stack that is larger than zero. 
<P>Here is an example of a correctly (though confusingly) indented piece of Python code:
<PRE>
def perm(l): 
        # Compute the list of all permutations of l 
    if len(l) &lt;= 1: 
                  return [l] 
    r = [] 
    for i in range(len(l)): 

             s = l[:i] + l[i+1:] 
             p = perm(s) 
             for x in p: 
              r.append(l[i:i+1] + x) 
    return r 
</PRE>
<P>The following example shows various indentation errors:
<PRE>
     def perm(l):                       # error: first line indented 
    for i in range(len(l)):             # error: not indented 
        s = l[:i] + l[i+1:] 
            p = perm(l[:i] + l[i+1:])   # error: unexpected indent 
            for x in p: 
                    r.append(l[i:i+1] + x) 
                return r                # error: inconsistent dedent 
</PRE>
<P>(Actually, the first three errors are detected by the parser; only the last error is found by the lexical analyzer  the indentation of <CODE>return r</CODE> does not match a level popped off the stack.)
<H4><A NAME="HDR9"> 2.1.8  Whitespace between tokens</A></H4>
<P>Except at the beginning of a logical line or in string literals, the whitespace characters space, tab and formfeed can be used interchangeably to separate tokens. Whitespace is needed between two tokens only if their concatenation could otherwise be interpreted as a different token (e.g., ab is one token, but a b is two tokens).
<H3><A NAME="HDR10"> 2.2  Other tokens</A></H3>
<P>Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist: <I>identifiers</I>, <I>keywords</I>, <I>literals</I>, <I>operators</I>, and <I>delimiters</I>. Whitespace characters (other than line terminators, discussed earlier) are not tokens, but serve to delimit tokens. Where ambiguity exists, a token comprises the longest possible string that forms a legal token when read from left to right.
<H3><A NAME="HDR11"> 2.3  Identifiers and keywords</A></H3>
<P>Identifiers (also referred to as <I>names</I>) are described by the following lexical definitions:
<PRE>
identifier:     (letter|"_") (letter|digit|"_")* 
letter:         lowercase | uppercase 
lowercase:      "a"..."z" 
uppercase:      "A"..."Z" 
digit:          "0"..."9" 
</PRE>
<P>Identifiers are unlimited in length. Case is significant.
<H4><A NAME="HDR12"> 2.3.1  Keywords</A></H4>
<P>The following identifiers are used as reserved words, or <I>keywords</I> of the language, and cannot be used as ordinary identifiers. They must be spelled exactly as written here:
<PRE>
and        elif       global     not        try       
break      else       if         or         while     
class      except     import     pass      
continue   finally    in         print     

def        for        is         raise     
del        from       lambda     return
</PRE>
<H4><A NAME="HDR13"> 2.3.2  Reserved classes of identifiers</A></H4>
<P>Certain classes of identifiers (besides keywords) have special meanings. These are:
<P><A HREF="ref2.tbl_2.ps"><IMG SRC="fm2html-table.gif">Table 1: Special Meanings of Identifiers 
</A>
<PRE>
---------------------------------------------
Form     Meaning                               
---------------------------------------------
  _*     Not imported by from module import *  
<CODE>  __*__</CODE>  System-defined name                   
<CODE>  __*</CODE>    Class-private name mangling           
---------------------------------------------
</PRE>
<P>(XXX need section references here.)
<H3><A NAME="REF40553"> 2.4  Literals</A></H3>
<P>Literals are notations for constant values of some built-in types
<H4><A NAME="HDR14"> 2.4.1  String literals</A></H4>
<P>String literals are described by the following lexical definitions:
<PRE>
stringliteral:   shortstring | longstring 
shortstring:     "'" shortstringitem* "'" | '"' shortstringitem* '"' 
longstring:      "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
shortstringitem: shortstringchar | escapeseq 
longstringitem:  longstringchar | escapeseq 
shortstringchar: &lt;any ASCII character except "\" or newline or the quote&gt; 
longstringchar:  &lt;any ASCII character except "\"&gt; 
escapeseq:       "\" &lt;any ASCII character&gt; 
</PRE>
<P>In plain English: String literals can be enclosed in single quotes (') or double quotes ("). They can also be enclosed in groups of three single or double quotes (these are generally referred to as <I>triple-quoted strings</I>). The backslash (\) character is used to escape characters that otherwise have a special meaning, such as newline, backslash itself, or the quote character.
<P>In "long strings" (strings surrounded by sets of three quotes), unescaped newlines and quotes are allowed (and are retained), except that three unescaped quotes in a row terminate the string. (A "quote" is the character used to open the string, i.e. either <CODE>'</CODE> or <CODE>"</CODE>.)

<P>Escape sequences in strings are interpreted according to rules similar to those used by Standard C. The recognized escape sequences are:
<P><A HREF="ref2.tbl_1.ps"><IMG SRC="fm2html-table.gif">Table 2: <B>Escape Sequences</B> 
</A>
<PRE>
------------------------------------------------------
Escape Sequence  Meaning                                
------------------------------------------------------
<CODE>\</CODE><I>newline</I>       Ignored                               
<CODE>\\</CODE>             Backslash (<CODE>\</CODE>)                      
<CODE>\'</CODE>                Single quote (<CODE>'</CODE>)                      
<CODE>\"</CODE>             Double quote (<CODE>"</CODE>)                      
<CODE>\a</CODE>             ASCII Bell (BEL)                      
<CODE>\b</CODE>             ASCII Backspace (BS)                  
<CODE>\f</CODE>             ASCII Formfeed (FF)                   
<CODE>\n</CODE>             ASCII Linefeed (LF)                   
<CODE>\r</CODE>             ASCII Carriage Return (CR)            
<CODE>\t</CODE>             ASCII Horizontal Tab (TAB)            
<CODE>\v</CODE>             ASCII Vertical Tab (VT)               
<CODE>\</CODE><I>ooo</I>           ASCII character with octal value <I>ooo</I>  
<CODE>\x</CODE><I>xx...</I>        ASCII character with hex value <I>xx...</I>   
                                                        
------------------------------------------------------
</PRE>
<P>In strict compatibility with Standard C, up to three octal digits are accepted, but an unlimited number of hex digits is taken to be part of the hex escape (and then the lower 8 bits of the resulting hex number are used in all current implementations...). 
<P>Unlike Standard C, all unrecognized escape sequences are left in the string unchanged, i.e., <I>the backslash is left in the string.</I> (This behavior is useful when debugging: if an escape sequence is mistyped, the resulting output is more easily recognized as broken. It also helps a great deal for string literals used as regular expressions or otherwise passed to other modules that do their own escape handling.)
<H5><A NAME="HDR15"> 2.4.1.1  String literal concatenation</A></H5>
<P>Multiple adjacent string literals (delimited by whitespace), possibly using different quoting conventions, are allowed, and their meaning is the same as their concatenation. Thus, "hello" 'world' is equivalent to "helloworld". This feature can be used to reduce the number of backslashes needed, to split long strings conveniently across long lines, or even to add comments to parts of strings, for example:
<PRE>
regex.compile("[A-Za-z_]"       # letter or underscore
              "[A-Za-z0-9_]*"   # letter, digit or underscore
             )

</PRE>
<P>Note that this feature is defined at the syntactical level, but implemented at compile time. The `+' operator must be used to concatenate string expressions at run time.
<H4><A NAME="HDR16"> 2.4.2  Numeric literals</A></H4>
<P>There are four types of numeric literals: plain integers, long integers, floating point numbers, and imaginary numbers.
<H5><A NAME="HDR17"> 2.4.2.1  Integer and long integer literals</A></H5>
<P>Integer and long integer literals are described by the following lexical definitions: 
<PRE>
longinteger:    integer ("l"|"L") 
integer:        decimalinteger | octinteger | hexinteger 
decimalinteger: nonzerodigit digit* | "0" 
octinteger:     "0" octdigit+ 
hexinteger:     "0" ("x"|"X") hexdigit+ 
nonzerodigit:   "1"..."9" 
octdigit:       "0"..."7" 
hexdigit:       digit|"a"..."f"|"A"..."F" 
</PRE>
<P>Although both lower case `l' and upper case `L' are allowed as suffix for long integers, it is strongly recommended to always use `L', since the letter `l' looks too much like the digit `1'. 
<P>Plain integer decimal literals must be at most 2147483647 (i.e., the largest positive integer, using 32-bit arithmetic). Plain octal and hexadecimal literals may be as large as 4294967295, but values larger than 2147483647 are converted to a negative value by subtracting 4294967296. There is no limit for long integer literals apart from what can be stored in available memory. 
<P>Some examples of plain and long integer literals:
<PRE>
7     2147483647                        0177    0x80000000 
3L    79228162514264337593543950336L    0377L   0x100000000L 
</PRE>
<H5><A NAME="HDR18"> 2.4.2.2  Floating point literals</A></H5>
<P>Floating point literals are described by the following lexical definitions:
<PRE>
floatnumber:    pointfloat | exponentfloat 
pointfloat:     [intpart] fraction | intpart "." 
exponentfloat:  (intpart | pointfloat) exponent 
intpart:        digit+ 
fraction:       "." digit+ 
exponent:       ("e"|"E") ["+"|"-"] digit+ 
</PRE>
<P>The allowed range of floating point literals is implementation-dependent.  Some examples of floating point literals:
<PRE>
3.14    10.     .001    1e100   3.14e-10 
</PRE>
<H5><A NAME="HDR19"> 2.4.2.3  Imaginary literals</A></H5>
<P>Imaginary literals are described by the following lexical definitions:
<PRE>
imagnumber:     (floatnumber | intpart) ("j"|"J")

</PRE>
<P>An imaginary literals yields a complex number with a real part of 0.0. Complex numbers are represented as a pair of floating point numbers and have the same restrictions on their range. To create a complex number with a nonzero real part, add a floating point number to it, e.g. (3+4j). Some examples of imaginary literals:
<PRE>
3.14j   10.j    10 j    .001j   1e100j  3.14e-10j 
</PRE>
<P>Note that numeric literals do not include a sign; a phrase like <CODE>-1</CODE> is actually an expression composed of the unary operator `<CODE>-</CODE>' and the literal <CODE>1</CODE>.
<H3><A NAME="HDR20"> 2.5  Operators</A></H3>
<P>The following tokens are operators:
<PRE>
+       -       *       **      /       % 
&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~ 
&lt;       &gt;       &lt;=      &gt;=      ==      !=      &lt;&gt; 
</PRE>
<P>The comparison operators <CODE>&lt;&gt;</CODE> and <CODE>!=</CODE> are alternate spellings of the same operator; != is the preferred spelling,  &lt;&gt; is obsolescent.
<H3><A NAME="HDR21"> 2.6  Delimiters</A></H3>
<P>The following tokens serve as delimiters in the grammar:
<PRE>
(       )       [       ]       {       } 
,       :       .       `       =       ; 
</PRE>
<P>The period can also occur in floating-point and imaginary literals. A sequence of three periods has a special meaning as ellipses in slices.
<P>The following printing ASCII characters have special meaning as part of other tokens or are otherwise significant to the lexical analyzer:
<PRE>
'       "       #       \ 
</PRE>
<P>The following printing ASCII characters are not used in Python. Their occurrence outside string literals and comments is an unconditional error:
<PRE>
@       $       ? 
</PRE>


<P><A HREF="ref.book.html"><IMG SRC="fm2html-toc.gif">Table of Contents</A>
<A HREF="ref3.html"><IMG SRC="fm2html-next.gif">Next Chapter</A>
